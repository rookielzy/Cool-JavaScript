# Automated testing with mocha
自动测试将会在未来许多的场景下得到使用

自动测试俨然成为了一名开发者必备的技能之一

# Why we need tests?
当我们在写一个函数的时候，我们经常会想象它会做什么，不同的参数会给出怎样不同的结果。

在开发期间，我们可以通过运行这个函数来对比期望值与结果。例如，我们可以在终端中做上述的事。

如果代码出错了，我们就可以修改代码，重新运行然后检查结果，直到函数能按预期工作。

但是这种手动的重新运行并不完美。

## When testing a code by manual re-runs - it's easy to miss something
比如，我们创建一个`f`函数，在其中添加代码，测试`f(1)`正常工作，但`f(2)`不能正常工作。我们修复了代码，现在`f(2)`可以工作了。是不是看起来好像工作完成了？但是我们忘记了重新测试`f(1)`是否还能正常工作，这可能会导致另一个问题的出现。

这是非常典型的例子，但我们在开发某些东西时，我们在心里记住许多的可能出现的结果。但是对开发人员来说，是否能顺利地手动检查每一次改动，是非常难以预测的。因此这就会很容易导致解决了一个问题，另一个问题又出现了。

**自动测试意味着它是主代码以外单独编写的测试代码。它们可以很顺畅地运行和检查所有主要案例**

# Behavior Driven Development(BDD)
让我们来探讨一下行为驱动开发，简称BDD。这种开发方式应用在许多的项目当中，它不只是用于测试，还有更多有用的功能。

## BDD is three in one: tests AND documentation AND examples
说了这么多，让我们来看看以下的例子

## Development of "pow": the spec
假设我们想要一个`x`的`n`次方的函数`pow(x, n)`。假设`n>=0`

这个例子在`JavaScript`中使用`**`操作符就可以完成，但是这次我们将专注于探讨更复杂的开发流程。

上述描述也被称为“规范化”，比如：

```js
describe("pow", fucntion() {

    it("raises to n-th power", function() {
        assert.equal(pow(2, 3), 8);
    });

})
```
从上面的内容中你可以看出“规范化”有三大模块

`describe("title", function() { ... })`

描述这个函数是干什么。然后用`it`把它的具体内容给包裹起来。在这个例子中，它描述的是`pow`这个函数

`it("title", function() { ... })`

在`it`的`title`中，我们用一种可读性强的描述方式来指出函数的用处，第二个参数就是用来测试这个函数的。

`assert.equal(value1, value2)`

`it`中的代码，如果能顺利运行，那么久不应该出现任何错误。

`assert.*`函数是用来测试`pow`是否能预期运行，在这里 我们使用其中一种方法`assert.equal`，它将会对比所有参数，如果对比结果不相同，它就会提出一个错误。在这个例子中，它会测试`pow(2, 3)`的结果是否等于`8`.

在接下来的文章中，我们将会看到更多不同类型的对比测试。

## The development flow
开发流程通常看起来如下描述：

1. 规范化的初始化，并附带基本的主体测试功能
2. 创建规范化的实现方法
3. 为了测试它是否能正常工作，我们使用`mocha`测试框架来测试上述的规范化，并修复所有出现的错误，直到它能正常工作。
4. 现在我们有一个可工作的测试实现方法
5. 我们将添加更多的测试实例，可能规范化中还不支持，这时候就会出现错误
6. 返回第三步，更新规范化，直到它能正常工作
7. 重复第三到第六步，直到功能能完全正常工作

因此，程序开发的过程中是不断迭代的。我们在这个过程中不断地编写规范，实现它，确保它能通过所有的测试，然后再编写更多的测试实例，再次确保它能如预期工作。在最后，我们就将会拥有一个可工作的规范实现方法和测试方法。

在我们的例子中，我们完成了第一步：编写`pow`的规范。接下来让我们来编写规范的实现方法，在这之前，先添加一个空输入在规范中，测试所有测试能够正常工作。

## The spec in action
接下来就是关于一些测试的`JavaScript`的库的介绍

